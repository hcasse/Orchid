# Implementing a Custom Component

Orchid components have to cooperate with an HTML client through the
HTTP interface. So they are usually split into 2 parts:
* Python's part (that implements most of the behaviour and the interface with the application),
* HTML's part (that provides the display and the capture of events used by the component).

And the component, with the help of Orchid, has to make both parts to communicate.
On Python's side, `Component` methods are provided for this. On HTML's side, the behaviour and the communication are implemented in Javascript and with some functions provided by Orchid.

Lets start an example component that display some counter value and increment it each time it is clicked. It is named `Counter`.

## HTML's Side

The component is displayed in HTML as a label followed by the counter value like that:

```html
<div> LABEL CNT</div>
```

As it has to be click-senstive we add the event handler:

```html
<div onclick='counter_onclick("ID", event);'> LABEL CNT</div>
```

When clicked, the function `counter_click` is called with the identifier of the component _ID_ (we will see later how to generate it) and the _event_ generated by HTML client.

We have to provide the implementation in Javascript like this:

```javascript
function counter_onclick(id, event) {
	if(event.button == 0) 
		ui_post({id: id, action: "click"});
}
```

This function, that has to provided in the generated HTML (we will see later how) is invoked on each click and test if the click concerns the left buttons. If true, a message is send back to the Orchid server for the component corresponding to _id_ with the action we named `click` (this may be any name supported by the corresponding object).

For mouse events, it is a good idea to use the Orchid function `ui_post()` as it let other component to react to this event as the post just record the message to send until `ui_complete()`is invoked (usually performed at the `<body>` level).

There is also a function `ui_send()` that combines `ui_post()` with `ui_complete()`. The passed message must be a Javascript record that contains at list an `id` entry with the identifier of the compmonent.

That's all  on the client side. Lets write now the server side.


## Python's Side

In order to implement the component, one has to create a class inheriting
from Orchid's `Component`:

```python
from orchid import *

...

class Counter(Component):

	def __init__(self, message):
		Component.__init__(self, MODEL)
		self.message = message;
		self.count = 0
		self.set_attr('onclick',
			"counter_onclick('%s', event);" % self.get_id())
```

The initialization method calls the parent class initializer and set the`count` variable to 0. Then, we set the attribute `onclick` for the generated HTML element to the call to  `counter_onclick()` function and using method `get_id()`, we replace _ID_ by the actual identifier of the component.

**Notice** that attributes are generated with double-quotes and therefore, Javascript strings has to be expressed between single quote.

`MODEL` will be discussed later.

Then we have to write the HTML generator function:

```python

	def display(self):
		return '%s %d' % (self.message, self.count)

	def gen(self, out):
		out.write('<div');
		self.gen_attrs(out);
		out.write('>')
		out.write(self.display())
		out.write('</div>')
```

The `gen()` is called to generate the HTML page. It takes as parameter an object supporting `write()` to append content to the page. Basically, we generate the HTML component as presented in the HTML's side part. The only difference is the use of `gen_attrs()` method that generates the attributes of `<div>` element (including CSS style and classes) that may have been set up by other components/page like containers.

Now, we can start to react to the click from the client side:
```python
	def receive(self, message, handler):
		if message['action'] == 'click':
			self.count = self.count + 1
			self.set_content(self.display())
		else:
			Component.receive(self, message, handler)
```

The method `receive()` is called each time the client issues a message for your component (using `ui_post()` Javascript function). Then the method can examine the message to find the action `click` or pass it back to the parent class `receive()` message.

The structure passed to `ui_post()` is decoded a Python's dictionary in `msg` and the `action`can be checked. The the counter is incremented and the content of the HTML element is updated with function `set_content()`.

In fact, the process supports that several messages can be sent from the client and then the answers (other messages) from one or several components are collected and send back to the client. The answers are modifications of the HTML structure and so of the display of the application.

Several function exists to update the client-side HTML (look to `AbstractComponent` documentation):

* `remove_attr()`, `set_attr()`
* `add_class()`, `remove_class()`, `set_style`()
* `append_content()`, `clear_content()`, `insert_content()`, `set_content()`
* `call()` (to call a Javascript component's function)


## Running the example

The code below shows two counters:

```python
from orchid import *

class MyPage(Page):

	def __init__(self, app):
		Page.__init__(
			self,
			VGroup([
				Counter("Counter 1:"),
				Counter("Counter 2:")
			]),
			app = app
		)

class MyApp(Application):

	def __init__(self):
		Application.__init__(self, "Counter Test")
		self.fst = MyPage(self)

	def first(self):
		return self.fst

run(MyApp())
```

## Models and Lookup

Until now, we have defined the component in Python and the generated code but we do not  talk about the generation of function `counter_click()`. In fact, as this code is common to all instances of `Counter`, its declaration is grouped in a `Model` object:

```python
MODEL = Model(
	script = """
		function counter_onclick(id, event) {
			if(event.button == 0) 
				ui_post({id: id, action: "click"});
		}
"""
)
```
`MODEL` is the same object as passed to the `Component` initializer. Resources listed in a `Model` are then generated at the right place in the HTML page. In addition, this allows to duplicate the same declaration in the generated page.

A `Model` supports:

* straight code Javascript,
* paths of script files,
* straight CSS code,
* paths of CSS files.

Basically, the files are retrieved from a list of directories that can be configured in the `run()` call and in the application initialization. Additionally, the `assets` directory of Orchid is also looked for.

`MODEL` is also the right place to provide display configuration of your component. The code below add a box and a sensitivity to mouse-over to our component:

```python
MODEL = Model(
	script = ...,
	style = """
		.counter {
			border: 2px solid red;
			padding: 4px;
		}

		.counter:hover {
			background: yellow;
		}
	"""
)
```

Now we have to set the class `counter` to our component. This can be performed in the initialization by calling:

```python
	def __init__(self, message):
		...
		self.add_class('counter')
```

You can find back this code in `test/counter.py`.

# Semantic UI

Module `mind` provides classes bringing more *semantics* to the UI generated by **Orchid**. The application is seen as a collection of data stored in variables (class `Var`) on which actions (class `Action`) may be applied depending if the action is active or not.

The components are only display vectors of the application data and they maintain a good lookup depending on the transformations of the data. In the end, the user has hust to focus on application data and actions and let the UI to maintain automatically its consistency.

The lookup of data of actions is maintained by a class, named *Entity*, that records humand readable-labels, help messages, icons, etc. Both `Var`and `Action`extends this class and can therefore be customized.

*This module is in development and is subject to evolve a lot to provide its full power.*




## Application Data

Data of the application are stored in `Var` objects. `Var` objects are typed and can be observed. This observation property (subject-observer model) allows to maintain of the UI with the application. Each time the `Var` is modified, the UI is automatically updated and the UI updates the data each time it is modified by the user.

The type will allow (but it is not compeltely implemented) to generate a part of the UI.

So basically, a `Var`is created by a call to `var`() function:

```python
from orchid.mind import *

x = var(0)
```

In this case, the type is deduced from the initialization value (`int` in this case) but it can also be passed at build time:

```python
x = var(0, int)
```

The entity configuration in the variable can also be passed to this constructor:
```python
x = var(0, label="My variable", help="This is my variable, an integer!")
```

After that, it is very simple to build a field to handle this variable:
```python
from orchid import *

my_field = field(x)
```

Then each time, the variable is changed, the field will be automatically modified:
```python
x.set(100)
```

In addition, the application may be notified of a change of `x`:
```python
def XObserver(Observer):

	def update(self, subject):
		print("X modified:", x.get())

x.add_observer(XObserver())
```

Notice that `x.get()` can be shortened to `~x` (with the rarely used operator `~`). If you want to use it on x, just write `~x.get()`.




## Actions and Predicates

Actions are triggered by a user action (button, menu, etc) and perform some task in the application on the data. Basically, an action must implemtn the `AbstractAction` interface:

```python
class AbstractAction(Entity):

	def is_enabled(self):
		...

	def perform(self, interface):
		...
```

`perform` is called when the action is triggered when the user activates a button or any other action triggerrer. It takes as parameter an interface (class `orchid.util.Interface` that provides a link to interact with user in any way independent of the real underlying UI).

Basically, an action can only be performed under some conditions which state is provided by the function `is_enabled()`. Basically, ths UI component triggerring, like buttons, an action uses this function to be enabled or not. The default implementation of `is_enabled()` returns true.

Often, `is_enabled()` is implemented with predicates (class `Predicate`) as in the class `Action`. `Action` takes as parameter a predicate and function to call when the action is performed.

```python
x = var(None, int)
field = Field(var)

def perform(self, interface):
	print("x =", ~x)

action = Action(fun=perform, pred=not_null(x))
button = Button(action)
```

`not_null()` builds a predicate that returns true if the variable is not false (as for a condition of Python). At beginning, `button` is disabled and when some value different from 0 is typed in `field`. When `button` will be clicked, function `perform` is called.

Notice that an action can be used with several activators and a predicate can be used with several actions.

```python
x = var(None, int)
field = Field(var)

def inc(self):
	x.set(~x + 1)
def dec(self):
	x.set(~x - 1)

predicate = not_null(x)
increment = Action(fun=inc, pred=predicate, label="Increment")
decrement = Action(fun=dec, pred=predicate, label="Decrement")

inc_but = Button(increment)
dec_but = Button(decrement)
inc_menu = MenuButton(increment)
dec_menu = MenuButton(decrement)
```

In the end, the idea is that now an application (or a page of an application) is structured as:
* a	set of data stored in `Var` objects,
* a set of actions representing the different activities of the application.

Once this is defined and possibly tested separately from the UI, one or several UIs can be designed for the application but back-end and front-end designs are kept seperate.




## Complex Data Sets

